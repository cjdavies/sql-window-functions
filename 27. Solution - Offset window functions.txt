Solution - Offset window functions

The first step is to identify each quarter. And, I really hope you heeded my tip, and used quarter start dates as their identifiers, and were not tempted to extract quarter number and years from the dates. If you did, I bet you quickly realized what a hassle they are when dealing with cross-year boundaries. I chose to use MAKE_DATE with DATE_PART, but any other method is fine, as long as you end up with the date type to work with. All I need are the species and the quarters. At the bottom of the solution file, you will find an alternative query that uses extract. Now, I can figure out quarterly adoptions and then some. The first challenge is to find the right grouping expressions. I need to calculate quarterly adoptions, both for each species, and for all species. One option is to write two separate queries, one that groups by quarter and species, and another that groups only by quarter, and then union them. And, there's nothing wrong with this approach, and in fact, I used it for the alternative query, which you know where to find. What I did choose to use is a very powerful, but unfortunately less frequently used feature of SQL called grouping sets. Grouping sets create multiple row groups in a single query. Group by grouping sets, quarter and species, and only quarter, will add super-aggregate rows for all species for each quarter with a null for species. Magically, we have a new row group, representing all species for each quarter, which is going to significantly simplify all upcoming calculations. The COUNT(*) group aggregate function counts all adoptions for each quarter and species. At this point, we're ready to calculate the difference from the previous quarter. This is the current quarter's count, minus the previous quarter's count, which I get with FIRST_VALUE, partition by species, and a frame that starts and ends with an interval of three months preceding, a.k.a. previous quarter-start. Now, you see why using the quarter start date as its identifier is such a good idea. For quarters that follow quarters with no adoptions, the frame is going to be empty, and the function will return a null. Subtracting a null from an integer results in a null. So, I must use COALESCE, and replace them with zeroes. I also identify the first quarter for each species with a CASE conditional expression, comparing the current quarter with the first one for its species, with another first value, partitioned by species and ordered by quarter start. The frame's end boundary doesn't really matter, as we referenced the first value in the frame. But, I chose to use what I consider to be logically correct, a frame that covers the whole partition. If the current quarter is also the first quarter, this expression evaluates to a zero. For all other quarters, a null. And, you'll see why I do that in the next step. Another valid option is to use a Boolean expression, which I did for the alternative query. While you're checking out the alternative query, also notice the slightly different logic using LAG, it's pretty cool. Now, that was the hard part. All that's left is to rank each quarter for each species. The COALESCE will return zero for the first quarter. And, for all other quarters, where it is a null, the actual difference from the previous quarter is used for the rank, as per the requirements. The quarter-start descending tiebreaker guarantees that the most recent quarter is used in case of ties. And lastly, filter for rows with a rank of five or less, revert the quarter identifiers back to year and quarter number, and sorted per the requirements. SQL and window functions are so mind-blowing amazing, aren't they?
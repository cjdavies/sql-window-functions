PARTITION BY and ORDER BY

The second filter we can place in front of our window is the partition by clause. To partition something, means to divide it into parts and this is exactly what partition by does. The partitioning expressions limit the function's visible window only to rows that share the same values as the current row. Let's bring back the simplified animal set. Partition by species limits the function visibility to animals of the same species. For Buddy's row, the window is limited to his and Abby's. And the same is true for Abby. For Pumpkin, the window is limited to cats. Only herself in this case, and similarly for Peanut. Let's bring back the Max name function and add partition by species. For the first row, the function won't see the entire set. It will only see cats and Felix is the winner. The following row happens to be a cat too, so the function picks Felix once again. Next, is Prince. Prince is a dog, so the function no longer sees cats. It sees only dogs and this time Winston is the lucky winner. The same is true for all dogs that share a partition. Milly, our only rabbit's partition, consists of just her row, and the maximal name is the only name, our dear lonely Milly. Here is the same animal's query that we used before. This time, instead of a grand total, we need to add a column that shows the total number of animals of the same species as the current row. Using a sub-query solution requires introducing a correlation between the parent query and the sub-query so that the count is limited only to animals of the same species. This requires unique aliases to distinguish between the two instances of the table, A1 and A2. When using table aliases, I highly recommend that you qualify all expressions to avoid confusion. To solve this with a window function, all we need to do is add a partition by clause to limit the count of the animals to the same species. It is equivalent to the correlation term we just used for the sub-query. However, it is significantly clearer. And performance-wise, the differences between these two queries is much more pronounced. The cost of the window function solution on my PC is around 11 versus 340 for the sub-query one. There is a more efficient solution that still uses a sub-query, one that doesn't require 100 aggregate iterations. Pause the video for a minute and see if you can find it. Query processing order to the rescue once again. Pre-aggregating the animal species counts and joining it in the from clause avoids the need for the correlated sub-query to be executed 100 times, once per row. This sub-query is non-correlated and will be executed only once. This solution's cost is about the same as the one of the window function, but of course, your mileage may vary. The order by clause is the most confusing part of the over clause. It serves completely different purposes using the same syntax which is never a good idea. I wish the ASCII SQL committee would've come up with a better syntax choice. But unfortunately, that's water under the bridge. Aggregate and frame offset window functions are inherently order agnostic. For these, order by is used for defining frames that further limit the rows visible to the function. For rank, row offset, and distribution window functions, order by defines how the function is evaluated. Now I know, these terms probably don't make much sense yet, but don't worry, we're going to cover all of them in the following chapters. I just wanted to include it here with the syntax overview. And now, onto framing, exclusions, and shortcuts.
How window functions fit in query processing

As we just saw, evaluation scope of standard expressions is limited to their own rows. We can create a new expression from existing ones but only from those that are on the same row. If we need to use a value from another row, we have no choice but to use a subquery. So to list the name of the second animal from the same species next to the current one, we must write this whole mess of a subquery. We must handle NOWs and probably need an aspirin afterwards. Well, had no choice is a more accurate term. Because this is exactly the limitation that window functions overcome. As their name suggests, window functions open a new window to other rows that can be accessed directly without a subquery. For every row we can use a window function to peek at values from other rows. But before we start coding window functions, we first need to understand their place. Window functions are limited to the select and order by clauses. Why, you ask. Very good question. Assume we have a hypothetical window function named previous that automagically retrieves the name of the animal with the closest previous admission date. Don't worry about the implementation, it's completely hypothetical. Our hypothetical function is used in the select list where it poses no logical challenges. The reason is that our data set has taken its final form so there is no ambiguity as to which animal is previous. But what if we try to use the function elsewhere in the query? Maybe in the WHERE clause? Let's see what happens. The WHERE evaluates each row using predicates and only rows that evaluate to true will make it to the next clause. In this trivial example, the logical issue may not be apparent. Theoretically, we can evaluate the function for each row and only Pumpkin evaluates to true. No problem, right? But, things get more interesting if we add additional predicates. For example, end species is different than cat. Pause the video for a minute, and see if you can guess the result. Now, the fun starts. If the predicate previous equals Abby is evaluated first, only Pumpkin evaluates to true like before. For the second predicate, Pumpkin evaluates to a false. The end logical operator causes Pumpkin to be eliminated from the result and no rows are returned. Let's roll it back and start over. This time, in a different order. If we evaluate the predicate species different than cats first, Pumpkin evaluates to false and is eliminated. When we evaluate the second predicate, it is now Peanut that evaluates to true. So, as you can see, the order of predicate evaluation determined the result. SQL does not allow for such ambiguities. It doesn't make any sense, and in fact, there is no order to predicate evaluation no matter which one we spell first. All predicates are evaluated at once as if they occur at the exact same point in time. And that's the reason why window functions that rely on the dataset, the whole dataset, and nothing but the dataset are not allowed before it takes its final shape and form. And this is true only in the select clause and the order by that follows, but not before.
RANK and DENSE_RANK

Rank assigns each row a number between one and the number of distinct values in a partition. If the values of the sorting expressions within the partition are all unique, the sequence will be monotonically increasing by one, which will be the equivalent of the row number. However, unlike row number, when a partition has tied sorting value expression rows, they are all assigned the same rank. The following value receives its rank disregarding the ties, hence introducing gaps in the sequence. Dense_Rank does a very similar thing, but as his name suggests, it avoids the gaps. These are best explained with an example. Let's revisit the routine checkup report we used two demos ago simplified to exclude species for which there were no checkups. Let's add columns for Rank and Dense_Rank, I will be reusing the over clause. So a window clause is probably an order. The row number generated a unique value for each row even though Ivy and Sadie had seven checkups each. And you already know that it could have been the other way around and just as correct. Rank assigns the same rank too to both Ivy and Sadie, and Charlie, the next cat in line with six checkups gets a rank of four. The three was skipped due to the duplicate ranks assigned to Ivy an Sadie. And similarly, we see larger gaps for Misty, Oscar and Simon with four checkups each and then Archie with three. Like Rank, Dense_Rank, assign the same rank to Ivy an Sadie, but it avoided the gaps and assign Charlie a rank of three. At this point, you may be asking yourself, well, what are all these nuances good for? I'll tell you that understanding these nuances is going to save you hours of frustration for slightly different requirements. For the row number, the requirement was to show the top three animals who had the most checkups. For that, we use the filter on the row number of three or less. You may also recall that we have three dogs tied for third place and three rabbits tied for second. What if we do need to include ties for third place, like the original sub-query solution did before we add a name to break the ties? This is a slightly different question. Show me the top three animals per species with the most checkups and include any animals tied for third place. And row number won't help us with that, but Rank is here to save our day. Replacing the where predicate to rows where the rank is three or less is going to do just that. For cats, it didn't change anything as they had no ties. For dogs, we now get five back, including Jake and Shadow that were missing from the previous query. And now I have a quiz for you. And this time, we're going to do a reversed quiz. I'm going to show you the query and you need to come up with a question. What is the question that is answered by the query, where our filter is for rows whose dense_rank is smaller than or equal to three? Pause the video for a minute and see if you can find the question. If you're not sure yet, let me execute it for you and give you another chance to figure it out. Pause the video again and see if it makes more sense. The question this query answers is not for the top three animals. It is for the top three distinct number of checkups. Show me all animals that have a number of checkups, which is one of the top three number of distinct checkups per species. And now you know what all these rank functions can do for you. And with that, I rest my case.
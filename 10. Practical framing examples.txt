Practical framing examples

Here are the two queries we used in the previous chapter to count the number of animals per species. We need to modify the number of species animals, so that instead of counting the total number of animals for each species, it will count only those that were admitted prior to it. This is the number of animals of the same species as we had in the shelter on the day before the current one. With the subquery solution, we can try adding a second correlation predicate so that the count will see rows that have a lower admission date than the current one. Using the Window function, let's attempt a frame sorted by admission date ascending with boundaries of unbounded preceding and current row. Let's execute and oops, something is off. Their results are different than those of the subquery solution. Stop the video for a minute and see if you can figure out the difference. The results are offset by one as the subquery solution does not include the current row's date due to the smaller than operator. The Window functions frame is defined up to the current row, and therefore does include the current day. For Tigger, the sub query returned a zero since no cats were admitted before it. The Window functions current row frame does and returns a one. If we want to include the current day, we can change the smaller than operator to a smaller than or equal to, and execute. And now it seems to deliver the same results as the window function with a current row frame. However, that's not what we want it. Their requirement was, show the number of animals admitted prior to the current day. Let's fix the Window function solution by changing the frame end to one preceding instead of current row, and execute. Side note. Rows one preceding, doesn't necessarily reference the calendar day before the current one. Unfortunately, our shelter doesn't admit animals every day, and rows one preceding, will point to the previous admission. However, for this query, it is irrelevant as the number of animals on the previous day is the same number of animals as it was since the last admission. And now it seems more in line with the subquery solution and with a requirement. However, unfortunately, things are rarely as they seem, and there's a nasty logical bug hiding here. Can you see it? Pause the video for a minute, and see if you can spot the lurking bug. To see this issue, we need to look for a day where two animals of the same species were admitted. This is a simple group aggregate query with a having clause for the count. Indeed, we have two dogs that were admitted on August 29, 2017. And a select star for this date, reveals that these are King and Prince. Let's limit our data to only dogs and only those that were admitted after August 1st, 2017, so we can focus on King and Prince without distractions. For the subquery solution, remember that the predicates must be added to both the parent query and the subquery. I find this duplicity ugly and error prone, and there's an easy way around it with a CTE. So, let's do that, and execute much better. Further Window functions solution, duplicity is not an issue. The Window function sees the data after the Where filter had its way with it. Let's compare the results. The subquery solution shows that zero dogs were adopted prior to both King and Prince. For Ranger, admitted about a month later, it returns a two. This is the correct answer to their requirement. Count the number of animals of the same species as it was on the previous day. The Window function solution returns zero for King but a one for Prince, and this doesn't make sense as they were adopted on the same day. Can you see why that is? Stop the video for a minute and see if you can figure it out. The reason this time is the frame type. For a rows frame, even though King and Prince have the same admission date, they are distinct animal rows. So, the frame still counts each one. And why did Prince get a one and not King? Well, there is no reason. This query is non-deterministic, meaning that the database may well return a one for King and zero for Prince, and it will still be a correct valid result. What we need here is a range frame. And once again, we should be careful as trying to change only the frame type, results in an error for a mismatch data type. The hint in the error message is helpful. It tells us that we can use an integer range offset for a date expression. What we need is that to change the integer one to an interval of one day to get the desired result. Now, look at these two queries and tell me which one is clearer and more elegant. And the icing on the cake is that the Window function query performance is about 10 times better than the subquery one. And we're just starting to have fun. Plenty more demos coming up soon.
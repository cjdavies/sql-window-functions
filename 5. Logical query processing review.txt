Logical query processing review

For those of you who haven't yet watched my query processing course, this video is going to be a speed-of-light review of some of the main concepts. Every query begins with the FROM clause, where the data set for the query is constructed. The data sources may be anything from a single table and up to joins of 50 shades of various different sources. All data sources, join qualifications, and reservations are evaluated and placed into a single data set that is then passed to the WHERE clause. WHERE evaluates each row using logical predicates. Rows for which the predicate evaluates to true will live to see another clause. All others are discarded, never to be seen again by the query. Then, this filtered set is passed to the GROUP BY clause. GROUP BY changes the fundamental structure of the set, from individual rows into row groups based on the grouping expressions. The group set is then shipped to the HAVING clause. HAVING uses logical predicates, as well, to evaluate entire row groups. Only groups for which these predicates evaluate to true, will get to see another clause. The row filtered grouped and grouped filtered set is then passed to the SELECT clause. SELECT evaluate each expression for every row or row group. These are the expressions that will be returned to the client application. Next, the set is passed to the ORDER BY clause. ORDER BY sorts the data set and at this point, it ceases to be a set and becomes a cursor. The cursor can be further processed by the query's final clause, the OFFSET FETCH, also known as LIMIT OFFSET, where it is sliced into manageable bite-sized pages for user consumption. Let's review this process once again from a different angle. Instead of looking at the syntax, let's follow the data set. Here is the data set after the from clause has completed its work. This set finds its way to the WHERE clause, where each row is evaluated with the predicates. Rows for which the predicate does not evaluate to true are discarded. The filtered set now moves on to the GROUP BY. GROUP BY creates row groups based on the grouping expressions, x in this case. Now we're no longer dealing with five individual rows. Instead, we have three row groups. This grouped set moves on to the HAVING filter The HAVING evaluates each row group with predicates. The first row group for which x is not larger than one is eliminated. And at this point the set has completed all its transformation and has taken its final form. All the following clauses, SELECT, ORDER BY, and OFFSET FETCH, will not modify it. The filtered and grouped set is passed to the SELECT. The SELECT evaluates each expression for each row group. The scope of each SELECT expression is limited to the same row or row group. And remember this fact. It's going to come in handy very soon. I'm not going to bother with sorting and paging for now. At this point, you might be wondering why you should even care about it, but oh, boy should you! Query processing order is one of the most fundamental aspects of SQL with far reaching implications, and window functions are no exception. So now that we have a general idea of how query processing works, let's see how window functions fit in this grand-scheme.
Row offset window functions

All Offset functions require a mandatory expression for what we want to fetch from the other row. Row Offset functions have two additional optional parameters. First is an Offset value and the second is a Default value replacement. The Default is used in case the Offset points to outside the partition boundaries or to a row that doesn't exist. If Offset is not specified, one is assumed. If a default is not specified, NULL will be used. IGNORE and RESPECT NULLS determine whether rows with NULL expressions are counted towards the Offset. The Default is RESPECT NULLS. Following are the optional PARTITION BY clause and the mandatory ORDER BY clause. Remember the ORDER BY in this case does not imply framing. And in fact, we can't specify a frame even if we really wanted to. Here is a row set ordered by the green column in ascending order. We're currently evaluating the highlighted third row. A lead with an Offset of one points to the following row and a LAG with the same Offset points to the previous row. Note that the Offset has nothing to do with the value gaps of the green values. It refers to the relative position and nothing else. The weight analysis was a lot of fun, so let's take it one step further. We need to write a query that returns all animal weight measurements and how much they gained or lost since their last checkup. This time we don't need the group by as we're looking for the individual measurements. Here is the base query to get us started. Let's add a column that subtracts current weight from the previous one using LAG weight, PARTITION BY species and name, ORDER BY checkup time ascending. Note that the first checkup for each animal returns a NULL weight gain as there are no previous measurements. I believe that this is purely a presentation issue that should be solved on the client side and not in the database. Nevertheless, let's see what we can do about it. First, a naive attempt to use a default string of not available will immediately run into reality check. We can't use a string as a default for a numeric column, makes sense. Even a COALESCE over the expression won't avoid this incompatibility. I've witnessed cases where developers were tempted to cast the inner numeric expression to a string which unfortunately is going to bite much harder. And to easily demonstrate this issue with this dataset, let's for a minute multiply weight gain by 100. I'll also change the ORDER BY to weight gain so that the issue will be easily visible. And looking at Charlie's row, everything seems to be okay. However, scrolling down reveals that for Simon, a minus 20 gain is sorted as being smaller than a minus 41. And this is the correct sorting for strengths but this is not what we are after. A zero won't do either. We can't use an integer literal as it is incompatible data type as well. Side note, I guess that PostgreSQL could have been a little bit more lenient here and implicitly convert the integer literal to a numeric for us. Other databases like SQL Server do that. That said, and if you know me just a little by now, you know that I will never complain about a database being too strict. The opposite is usually true. Changing the zero to a 0.0 works. But the result is not good either. Current weight minus zero is the current weight, not the weight gain. So using current weight as a default results in a zero gain for their first checkup, but that's no good either. If this set requires further processing, for example, averaging the weight gains, this zero is going to skew the results. The point I'm trying to make here is that we just don't know what the gain is for the first checkup and therefore it should remain a NULL. With all its complexities and all its anomalies, NULL is still the best way to deal with missing data. I guess that if the last three minutes end up saving you even four minutes sometime in the future, then it was well worth it.
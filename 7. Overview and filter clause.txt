Overview and filter clause

My favorite starting point is always right at the end. This is the basic syntax of a window function in all its fame and glory. Don't worry, we're not going to tackle it all at once. I just want you to keep it in the back of your mind as a roadmap. The function is, well, a function. We will cover all three function categories in due time. The function itself is less important for now, because we must first understand how it is processed. The OVER clause defines the window over the dataset, and most of these constructs are filters that limit the scope of the window that our function will see through. If we want the window to cover the whole set we can do without them by specifying a blank OVER clause. This looks less intimidating, right? Examples will follow shortly. FILTER is, well, a filter. Like the WHERE clause, FILTER limits the scope of the window with logical predicates. But unlike the WHERE that eliminated rows from the dataset and affected the rest of the query, FILTER limits the viewing scope only for the function where it lives. It has no side effects whatsoever on any other aspect of the query. WHERE species is not equal dog will exclude dogs from the window. The dogs are still there, and will be seen by all other select expressions. Only the current window function ignores them. Let's see a practical example. Here are our animals as they made it to the select. Like any expression, aggregate window functions are evaluated per row. Let's use a MAX name function with an empty OVER clause. The empty OVER clause causes the window to span the entire set. MAX name looks for the name with the highest dictionary sort order and finds Winston. This empty OVER clause is independent of any row value or its position, therefore it evaluates the same way for all rows within the set. Here is a query that returns a few attributes for all animals sorted by admission date. We need to add another column to this query to show how many animals we have in total. Before window functions, the only way was to use a non-correlated subquery that performs a COUNT over a second instance of the table. The window function equivalent is a COUNT star and an empty OVER clause. So far, no big difference. If we need to discard animals that were admitted prior to 2017, we should add a predicate. When we have a subquery solution that references two instances of the table, we must be careful. If only the subquery is filtered, it returns the 75 animals which were admitted in 2017 and later, but the parent isn't. It returns all 100 animals. And to eliminate these we must duplicate the predicate. With window functions we can add a FILTER clause, and like with the original subquery solution, the window function counts 75 animals, but the query itself returns all 100. Unlike the subquery, eliminating these does not require duplicate predicates. It's enough to filter in the WHERE clause and this data is all that the window function sees, so there's no more use for the filter. In terms of performance, window functions enable opportunities for the query optimizer by using a single instance of the table. Whether the query optimizer seizes these opportunities is a different question. On my PC, using PostgreSQL 12, the window function solution's total cost is around 6.5, versus nine for the subquery solution. It may sound like a lot, but these queries are so cheap that I doubt it will be even noticeable. Your mileage may vary.
Aggregate window functions

These are the common categories for aggregate functions. Most databases support most aggregate group functions as aggregate window functions too. You've probably used a few of these before, most likely, the arithmetic ones. Trivia fact, the word arithmetic comes from number art. Arithmos is number and tic is art. The NC SQL standard defines Boolean aggregate functions called every, any and some. Array aggregations are often extended to support JSON and XML formats. Statistical aggregates are plentiful and we're going to see a few later. And some databases add their own proprietary functions such as, Bitwise aggregations and Approximate functions that can offer better performance when accuracy is not critical. I can probably author a whole course just on aggregations. Now that I say it out loud, it actually sounds like a decent idea. Let me know in the Q and A section if you would like to see a course dedicated to aggregations. Routine check up is our largest table with about 300 rows. It stores results of monthly check ups for each animal. I deleted most of the original monthly rows at random just to save space. That's why not all animals have check ups. And those that do aren't monthly. We need to write a query that shows animal's species, name, check up time and heart rate. It should also include the Boolean column that evaluates to true for animals which every one of their heart rate measurements was either equal to, or larger than the average heart rate for their species. It's an interesting exercise that can be solved using sub queries derived, tables or window functions. If you want to try and solve it yourself, pause the video for a minute and give it a shot. Kudos to those of you who solved it no matter how. Calculating the average heart rate for each species is straightforward average aggregate window function, partitioned by species. Let's execute it first as is. To evaluate the Boolean expression, we'll use the every Boolean aggregate function. It will return true, only if all the elements are true. We partition it by both species and name so that the partition is limited to the current animal. If we inline the species average aggregate window function, as an argument within the every Boolean aggregate window functions, we will run into one of the limitations of window functions in general. Window functions cannot be nested. The NC SQL 2016 standard defines an exception with a feature called, nested window functions. Unfortunately, we don't have time to cover it in this course and even if I really wanted to demonstrate it, I can't. As I'm not aware of any database that has implemented this feature yet. We can circumvent this limitation with a common table expression, CTE, referencing the alias for this species average heart rate in the following query. If instead of showing this Boolean attribute, we need to use it as a filter and show only animals that are consistently at or above their species average, we might be tempted to try and copy it into the where clause. Only to be promptly reminded that window functions cannot be used in the where clause. And the way around it, is just to use another CTE and push the filter down one more level. All other aggregate window functions behave similarly. And we're going to cover plenty of them later. So I think that's enough for now. Let's see how we can use both window and group aggregate functions together.

Framing rows and ranges

Here's a window over a dataset that consists of six rows with a pair of integer values in each, call them the green column and the brown column. First, let's partition our window by the brown column. Partition boundaries are fixed. This means that for each row within a partition, a window function will always see all partition rows. Sometimes we need to further limit the scope of a window within each partition so that not all rows use the same window, and this is what framing is all about. To define a frame, we must introduce an order so that the terms first, last, next and previous make sense. There is no such thing as first or next without an order. So let's order our rows in both partitions by the green column, in ascending order and define frame boundaries. For example, a frame that begins at the current row and ends at the following one. For the first row, this frame covers one and two, The highlighted area that you see is what the window function sees instead of the whole partition. For the second row, our frame covers two and four, for the third, four and seven, and for the last row the frame will shrink as there is no next row, and the process repeats for each partition. Let's see the syntax and the options. First, we define our sorting in the ORDER BY clause. Let's use a set similar to the previous one and focus just on one partition. And we're evaluating the third row, the one with a green four. Next we specify one of three frame types, ROWS, RANGE or GROUPS. ROWS is probably the most intuitive type, so let's start with it. ROWS frame boundaries are specified using row position count. one row, 20 row, a million rows or all the rows that either precede or follow the current one. Row frames don't care what values are in these rows, they just count rows. Next we specify where the frame begins. UNBOUNDED PRECEDING points to the beginning of the partition. N PRECEDING and N FOLLOWING, point to any number of rows before or after the current one. N must be a none-null positive integer. One PRECEDING and one FOLLOWING, point to the next and previous immediate neighbor rows. CURRENT ROW, means, surprise, surprise, the current row, and I'm not joking when I say surprise, because as you'll soon see, CURRENT ROW, doesn't always mean what you think it means. The frame end is specified similarly. The difference is that UNBOUNDED PRECEDING is replaced with UNBOUNDED FOLLOWING. It doesn't make sense for a frame to start at the end of the partition nor to end at the beginning of it. Now, start and end are relative terms and depend on the sorting direction. So if we use descending order instead of ascending, the frame boundaries will be reversed. UNBOUNDED FOLLOWING and UNBOUNDED PRECEDING work the same way with all frame types, but that is not the case with N PRECEDING, N FOLLOWING and CURRENT ROW. RANGE frames are specified using value ranges that either precede or follow the current row regardless of how many rows they cover, and RANGE frames are data type dependent. So an integer range of 10 represents all rows that have a sorting value which is plus or minus 10 from the current rows value. Value not position. Unlike ROWS and GROUPS, that can use multiple sorting expressions, RANGE is limited to only one. Date and time ranges require an interval data type. For example, three seconds, 25 years or two months, five days and six milliseconds. For this set a RANGE frame of one PRECEDING and CURRENT ROW, evaluated for the highlighted row, covers only the current row, as the closest preceding neighbor is two integer values away. As long as our sorting expressions are unique within the partition, there is no confusion about what CURRENT ROW means because CURRENT ROW is also current value, but if the partition contains more than one row with the same sorting value, things get interesting. CURRENT ROW for RANGE frames doesn't refer to the current row's position like it did with the ROWS frame. For RANGE, it refers to the current row's value, and that includes all rows that share the same value. GROUPS frames are defined using the number of peer groups following or preceding the current row's group. A peer group is a set of rows that share the same sorting values. So when evaluated for the second row in this partition, a group frame that begins with one PRECEDING and ends with one FOLLOWING, will cover all partition rows. Sounds complex, right? Well, it is, but don't worry, it's going to make perfect sense as soon as we'll get some more practice. Let's do a practical example using our MAX name, but this time we'll add a frame. I sorted all rows in ascending name order within each species partition. This will make the visualization clearer, but remember that sets have no order. The partition is by species like before and the frame limits the function to see all rows that precede it, and up to the current row with name as our sorting expression. Let's start with Calvin. Calvin has the lowest sort order value name. His frame is limited to his own row and the function picks the only value that's available. For Felix, the frame extends to cover both him and Calvin. Felix has a higher sorting value than Calvin and so the function MAX picks him. Abby is next. Now, we switch to a new partition and the process repeats. The first frame covers one row, the second two and so on. If you look closely, you may spot something odd with these results. How come the results set exactly mirrors our source rows? Pause the video for a minute and see if you can figure it out. The reason is that I chose to use a MAX name function, together with a frame that is sorted also by name in ascending order. Therefore, any new row which is extended into the frame is guaranteed to have a larger sorting value than the previous one and will be picked up by the MAX. Now, this is not a very useful frame except as a visual example. Typically, we sort by one expression and use the function over another. Let's see some actual query fun.
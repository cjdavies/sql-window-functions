Frame offset window functions

Like the row offset functions, frame offset functions require a mandatory value to fetch expression. Nth value also requires an offset specification. Nth value supports an optional from first or from last clause, which determines whether the offset is evaluated from the beginning or from the end of the frame. The default is from first. Ignore and respect nulls work the same way as they did for row offset functions. Partitioning is optional, but framing is mandatory. Note that the order by is used both for the frame definition and also for the offset evaluation of nth value. Wouldn't it be nice if the frame and nth value could use different sort orders. As for the frame definition, mandatory is a bit of a strong word as we can omit it and specify only the order by. I highly recommend that you don't, as if you do, a frame will be assumed for you and it happens to be the same unfortunate one we saw for aggregate functions, range between, unbounded preceding and current row. Here is the same row set as before with a frame of rows between unbounded preceding and one following. First value points to the first frame row and for any frame that uses unbounded preceding, first value will always point to the same row for all partition rows. Last value points to the last row in the frame, which is one following in this example. The n boundary will keep advancing as the frame advances for each subsequent partition row. Lastly, nth value using an offset of two and the default from start points to the second row in the frame. Confused yet? Great. If not, let's see a code demo and try to confuse you some more. Here is the query we just used to calculate weight gains. The lag function doesn't care how long ago the previous checkup was, as it is based solely on the row's position, and therefore, these results can be highly misleading for any medical evaluation. A weight loss of half a pound in a week is much more alarming then a similar weight loss realized over a year. And to fix that, we need to replace the weight gain since the previous checkup with a weight gain, let's say over the past three months. This is slightly trickier and may not have a definite ultimate answer as we don't have data for every single month and yet let's give it a shot and see what we come up with. If your database never had any missing data points, you're more than welcome to skip this demo. Let's begin with a naive approach like before and work our way up. First, I'll try a first value using a range frame that begins three months before and ends with the current row. If I execute, I can immediately see that the results are very suspicious. When I see so many zeros and not a single null, although I know we have plenty of missing data points, my alarm bells start ringing. Do you see why that is? Pause the video for a minute and see if you can figure it out. There are no nulls as for all rows, regardless of the number or frequency of checkups, the frame has at least one row, the current one, that's also the reason for the zeros galore. First value for frame that consists of the current row is the current weight. If we look at Charlie's checkups from March 20th, 2018, we can see that his weight gain of 0.3 pounds was realized from one month before, not three. Now, I already admitted that the requirements are not complete. I said we needed to show the weight gain of the animal over the past three months, I didn't say what we should do if there are none or if there are only more recent measurements. Trying to limit the frame to only three months ago by replacing current row with three months preceding is not very helpful either. You may recall that range frames are data type dependent and checkup time is a timestamp. Postgres timestamps include the time of day with a resolution up to a microsecond. This means that the frame will catch a previous checkup only if it happened to take place precisely three months ago to the microsecond, and that's not very likely. Let's change that by explicitly casting checkup time to a date type instead. The frame now covers checkups that happened on the same date three months before, but regardless of the time of day. And these results are slightly more useful, although not much. We do get a few non-null results such as Charlie's latest two, as he happened to have had checkups at on the same day, three months before. Now, the purpose of this demo is not to come up with a definite ultimate answer, as I already said twice that the challenge is not well defined. What I do want to show you is some of the challenges that you may encounter when dealing with offset and ranges. But I can't leave you hanging without some sort of answer so here is what I would do if this was my application. I would use a frame of three months preceding and one day preceding. My reasoning is that if we're looking for abnormal weight differences over three months, these differences should be much more alarming if realized over shorter periods of time. I would change the query to sort by the absolute weight gain, not by animal and checkup time and note that Postgres does not allow for functions on order by expressions, which use aliases from the same query. And the error message is somewhat misleading. Other databases have no problem with it, and the workaround is simple, just wrap it in a CTE and sort in the following query. I would also add nulls last, so we don't have to scroll down to see our first real result. Alternatively, we can eliminate null rows in the (talks) clause. Even better is sorting by relative and not by absolute weight gain because a two-pound loss for a 50-pound dog is not as alarming as the same loss for a four-pound rabbit. This requires yet another CTE to calculate the percent change, and here are the results. And now if you'll excuse me, I really need to hurry, go check on Walter, it seems that something is very wrong with the poor guy.
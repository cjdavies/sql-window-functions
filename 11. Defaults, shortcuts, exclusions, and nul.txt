Defaults, shortcuts, exclusions, and null handling

The ANSI SQL standard defines shortcuts for frame boundary definitions by omitting the between keyword and one of the boundaries. So, instead of specifying between unbounded preceding and current row, we can just say unbounded preceding and current row will be assumed as the frame and vice versa for unbounded following. Between current row and current row is a legitimate frame. Can you see what is the difference between rows, range and groups current row? Pause the video for a minute and think about it. Rows current row is not very useful. The frame will consist of just the current row and to access expressions from the current row, we don't need window functions to begin with, we can access them directly. Range and groups current row will include the current row and all peer rows that have the same sorting values. These shortcuts may seem like a good idea at first, but I found that saving a few keystrokes may end up introducing confusion and bugs and it's just not worth it. As a rule of thumb, I recommend avoiding most syntax shortcuts, your code will be more readable and more portable, as not all databases support all shortcuts. While the frame boundary shortcuts that we see here aren't terribly bad, the next one is. I've seen it inflict so much damage and grief that I decided it deserves its own shaming slide. 

Window function syntax allows specifying ORDER BY without any explicit frame boundaries. The frame will assume the default of, wait for it, range between unbounded preceeding and current row. This is an unfortunate frame that is neither obvious nor intuitive. I have seen developers fall for this trap over and over and over again. There are window functions, ones that we haven't covered yet, where the ORDER BY isn't used for framing at all and they look the same and ORDER BY with no frame boundaries. To distinguish framing ORDER BY from a functional ORDER BY, you will need to remember which window functions support framing. 

Now you see why I recommend avoiding shortcuts. Consider the possibility that your successors won't necessarily understand or appreciate it. So always specify the full syntax. In the long run, it will save you hours of frustration, precious air, and plenty of aspirin. Window frames support an optional clause that excludes the current row or its peers from the frame. Assume the frame is the entire partition and we're evaluating the highlighted third row. When no frame exclusion is specified, the default is, exclude no others, where both the current row and its peers are included in the frame. Exclude group excludes both the current row and its peers, exclude ties, excludes the peers but keeps the current row and exclude current row excludes the current row but keeps the peers. There's nothing fancy or complicated about it, it's a simple useful feature and I wonder why most databases don't support it yet. Window functions of different categories handle NULLs differently. It wouldn't be interesting without it, right? Most aggregate functions ignore Nulls, rank and distribution functions respect NULLs, and so do frame boundaries. We'll deal with each of them later. The ANSI SQL standard defines an explicit no ordering clause that allows us to control whether NULLs are sorted first or last. It does not determine whether NULLs have the highest or lowest sorting value, because first and last are respected regardless if we're sorting by ascending or descending order. Be extra careful when migrating between platforms as not all databases support this clause, but even worse is that they don't all sort NULLs the same way. For Offset functions, the ANSI SQL standard defines a NULL treatment clause. It determines whether NULLs are respected or ignored for Offset purposes. We're going to deal with Offset functions later in this course so let's leave it at that for now. Queries with window functions often require reusing an OVER clause. For example, it is common to ask for both the minimal and the maximal value of an expression over the same window. To make our lives easier, the ANSI SQL standard defines a window clause. Instead of repeating an exceptionally long OVER clause, we can write it once, alias it and reuse the alias in the query. This minimizes typing, reduces the chances for errors and makes the query more readable, a win, win, win. We will use this very handy clause soon. Now, let's move on to the next chapter in which we'll explore aggregate window functions in depth.